<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Interface.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">r43ples</a> &gt; <a href="index.source.html" class="el_package">de.tud.plt.r43ples.management</a> &gt; <span class="el_source">Interface.java</span></div><h1>Interface.java</h1><pre class="source lang-java linenums">package de.tud.plt.r43ples.management;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.apache.log4j.Logger;

import de.tud.plt.r43ples.exception.InternalErrorException;
import de.tud.plt.r43ples.exception.QueryErrorException;
import de.tud.plt.r43ples.merging.FastForwardControl;
import de.tud.plt.r43ples.merging.MergeManagement;
import de.tud.plt.r43ples.merging.MergeQueryTypeEnum;
import de.tud.plt.r43ples.merging.MergeResult;
import de.tud.plt.r43ples.merging.RebaseControl;
import de.tud.plt.r43ples.triplestoreInterface.TripleStoreInterfaceSingleton;

<span class="nc" id="L20">public class Interface {</span>

	/** default logger for this class */
<span class="fc" id="L23">	private final static Logger logger = Logger.getLogger(Interface.class);</span>

	private static final int patternModifier = Pattern.DOTALL + Pattern.MULTILINE + Pattern.CASE_INSENSITIVE;

	/**
	 * 
	 * @param query
	 *            R43ples query string
	 * @param format
	 *            serialization format of the result
	 * @param query_rewriting
	 *            option if query rewriting should be enabled
	 * @return string containing result of the query
	 * @throws InternalErrorException
	 */
	public static String sparqlSelectConstructAsk(final R43plesRequest request,
			final boolean query_rewriting) throws InternalErrorException {
		String result;
<span class="fc bfc" id="L41" title="All 2 branches covered.">		if (query_rewriting) {</span>
<span class="fc" id="L42">			String query_rewritten = SparqlRewriter.rewriteQuery(request.query_sparql);</span>
<span class="fc" id="L43">			result = TripleStoreInterfaceSingleton.get()</span>
					.executeSelectConstructAskQuery(Config.getUserDefinedSparqlPrefixes() + query_rewritten, request.format);
<span class="fc" id="L45">		} else {</span>
<span class="fc" id="L46">			result = getSelectConstructAskResponseClassic(request.query_sparql, request.format);</span>
		}
<span class="fc" id="L48">		return result;</span>
	}

	/**
	 * @param query
	 * @param format
	 * @return
	 * @throws InternalErrorException
	 */
	private static String getSelectConstructAskResponseClassic(final String query, final String format)
			throws InternalErrorException {
<span class="fc" id="L59">		final Pattern patternSelectFromPart = Pattern.compile(</span>
				&quot;(?&lt;type&gt;FROM|GRAPH)\\s*&lt;(?&lt;graph&gt;[^&gt;\\?]*)(\\?|&gt;)(\\s*REVISION\\s*\&quot;|revision=)(?&lt;revision&gt;([^\&quot;&gt;]+))(&gt;|\&quot;)&quot;,
				Pattern.DOTALL + Pattern.MULTILINE + Pattern.CASE_INSENSITIVE);

<span class="fc" id="L63">		String queryM = query;</span>

<span class="fc" id="L65">		Matcher m = patternSelectFromPart.matcher(queryM);</span>
<span class="fc bfc" id="L66" title="All 2 branches covered.">		while (m.find()) {</span>
<span class="fc" id="L67">			String graphName = m.group(&quot;graph&quot;);</span>
<span class="fc" id="L68">			String type = m.group(&quot;type&quot;);</span>
<span class="fc" id="L69">			String revisionNumber = m.group(&quot;revision&quot;).toLowerCase();</span>
			String newGraphName;

<span class="fc" id="L72">			RevisionGraph graph = new RevisionGraph(graphName);</span>
					
			// if no revision number is declared use the MASTER as default
<span class="pc bpc" id="L75" title="1 of 2 branches missed.">			if (revisionNumber == null) {</span>
<span class="nc" id="L76">				revisionNumber = &quot;master&quot;;</span>
			}
<span class="fc bfc" id="L78" title="All 2 branches covered.">			if (revisionNumber.equalsIgnoreCase(&quot;master&quot;)) {</span>
				// Respond with MASTER revision - nothing to be done - MASTER
				// revisions are already created in the named graphs
<span class="fc" id="L81">				newGraphName = graphName;</span>
			} else {
<span class="fc bfc" id="L83" title="All 2 branches covered.">				if (graph.hasBranch(revisionNumber)) {</span>
<span class="fc" id="L84">					newGraphName = graph.getReferenceGraph(revisionNumber);</span>
				} else {
					// Respond with specified revision, therefore the revision
					// must be generated - saved in graph &lt;graphName-revisionNumber&gt;
<span class="fc" id="L88">					newGraphName = graphName + &quot;-&quot; + revisionNumber;</span>
<span class="fc" id="L89">					RevisionManagement.generateFullGraphOfRevision(graphName, revisionNumber, newGraphName);</span>
				}
			}

<span class="fc" id="L93">			queryM = m.replaceFirst(type + &quot; &lt;&quot; + newGraphName + &quot;&gt;&quot;);</span>
<span class="fc" id="L94">			m = patternSelectFromPart.matcher(queryM);</span>

<span class="fc" id="L96">		}</span>
<span class="fc" id="L97">		String response = TripleStoreInterfaceSingleton.get()</span>
				.executeSelectConstructAskQuery(Config.getUserDefinedSparqlPrefixes() + queryM, format);
<span class="fc" id="L99">		return response;</span>
	}

	/**
	 * currently not thread-safe
	 * 
	 * @param query
	 * @param user
	 * @param message
	 * @throws InternalErrorException
	 */
	public static void sparqlUpdate(R43plesCommit commit)
			throws InternalErrorException {

<span class="fc" id="L113">		final Pattern patternUpdateRevision = Pattern.compile(&quot;(?&lt;action&gt;INSERT|DELETE)(?&lt;data&gt;\\s*DATA){0,1}\\s*\\{&quot;,</span>
				patternModifier);
<span class="fc" id="L115">		final Pattern patternWhere = Pattern.compile(&quot;WHERE\\s*\\{&quot;, patternModifier);</span>

<span class="fc" id="L117">		final Pattern patternEmptyGraphPattern = Pattern.compile(&quot;GRAPH\\s*&lt;(?&lt;graph&gt;[^&gt;]*)&gt;\\s*\\{\\s*\\}&quot;,</span>
				patternModifier);
<span class="fc" id="L119">		final Pattern patternGraphWithRevision = Pattern</span>
				.compile(&quot;GRAPH\\s*&lt;(?&lt;graph&gt;[^&gt;]*)&gt;\\s*REVISION\\s*\&quot;(?&lt;revision&gt;[^\&quot;]*)\&quot;\\s*\\{&quot;, patternModifier);

<span class="fc" id="L122">		logger.debug(&quot;SPARQL Update detected&quot;);</span>


		// I. Take over prefixes and other head stuff
		String queryRewritten;
<span class="fc" id="L127">		Matcher m = patternUpdateRevision.matcher(commit.query_sparql);</span>
<span class="pc bpc" id="L128" title="1 of 2 branches missed.">		if (m.find()) {</span>
<span class="fc" id="L129">			queryRewritten = commit.query_sparql.substring(0, m.start());</span>
<span class="fc bfc" id="L130" title="All 2 branches covered.">			if (m.group(&quot;data&quot;) != null)</span>
<span class="fc" id="L131">				queryRewritten += &quot;INSERT DATA {&quot;;</span>
			else
<span class="fc" id="L133">				queryRewritten += &quot;INSERT {&quot;;</span>
		} else {
<span class="nc" id="L135">			throw new InternalErrorException(&quot;No R43ples update query detected.&quot;);</span>
		}

		// II. Rewrite INSERT and DELETE clauses (replace graph names in query
		// with change set graph names)
<span class="fc" id="L140">		List&lt;RevisionDraft&gt; revList = new LinkedList&lt;RevisionDraft&gt;();</span>
<span class="fc" id="L141">		m = patternUpdateRevision.matcher(commit.query_sparql);</span>
<span class="fc bfc" id="L142" title="All 2 branches covered.">		while (m.find()) {</span>
<span class="fc" id="L143">			String action = m.group(&quot;action&quot;);</span>
<span class="fc" id="L144">			String updateClause = QueryParser.getStringEnclosedinBraces(commit.query_sparql, m.end());</span>

<span class="fc" id="L146">			Matcher m2a = patternGraphWithRevision.matcher(updateClause);</span>
<span class="fc bfc" id="L147" title="All 2 branches covered.">			while (m2a.find()) {</span>
<span class="fc" id="L148">				String graphName = m2a.group(&quot;graph&quot;);</span>
<span class="fc" id="L149">				String revisionName = m2a.group(&quot;revision&quot;).toLowerCase();</span>

<span class="fc" id="L151">				RevisionGraph graph = new RevisionGraph(graphName);</span>
<span class="pc bpc" id="L152" title="1 of 2 branches missed.">				if (!graph.hasBranch(revisionName)) {</span>
<span class="nc" id="L153">					throw new InternalErrorException(&quot;Revision is not referenced by a branch&quot;);</span>
				}
<span class="fc" id="L155">				RevisionDraft d = null;</span>
<span class="fc bfc" id="L156" title="All 2 branches covered.">				for (RevisionDraft draft : revList) {</span>
<span class="pc bpc" id="L157" title="1 of 2 branches missed.">					if (draft.equals(graphName, revisionName))</span>
<span class="fc" id="L158">						d = draft;</span>
<span class="fc" id="L159">				}</span>
<span class="fc bfc" id="L160" title="All 2 branches covered.">				if (d == null) {</span>
<span class="fc" id="L161">					d = new RevisionDraft(graphName, revisionName);</span>
<span class="fc" id="L162">					revList.add(d);</span>
				}
<span class="fc" id="L164">				String graphClause = QueryParser.getStringEnclosedinBraces(updateClause, m2a.end());</span>

<span class="fc bfc" id="L166" title="All 2 branches covered.">				if (action.equalsIgnoreCase(&quot;INSERT&quot;)) {</span>
<span class="fc" id="L167">					queryRewritten += String.format(&quot;GRAPH &lt;%s&gt; { %s }&quot;, d.addSetURI, graphClause);</span>
<span class="pc bpc" id="L168" title="1 of 2 branches missed.">				} else if (action.equalsIgnoreCase(&quot;DELETE&quot;)) {</span>
<span class="fc" id="L169">					queryRewritten += String.format(&quot;GRAPH &lt;%s&gt; { %s }&quot;, d.deleteSetURI, graphClause);</span>
				}
<span class="fc" id="L171">			}</span>
<span class="fc" id="L172">		}</span>
<span class="fc" id="L173">		queryRewritten += &quot;}&quot;;</span>

		// III. Rewrite where clause
<span class="fc" id="L176">		Matcher m1 = patternWhere.matcher(commit.query_sparql);</span>
<span class="fc bfc" id="L177" title="All 2 branches covered.">		if (m1.find()) {</span>
<span class="fc" id="L178">			queryRewritten += &quot;WHERE {&quot;;</span>
<span class="fc" id="L179">			String whereClause = QueryParser.getStringEnclosedinBraces(commit.query_sparql, m1.end());</span>

<span class="fc" id="L181">			Matcher m1a = patternGraphWithRevision.matcher(whereClause);</span>
<span class="fc bfc" id="L182" title="All 2 branches covered.">			while (m1a.find()) {</span>
<span class="fc" id="L183">				String graphName = m1a.group(&quot;graph&quot;);</span>
<span class="fc" id="L184">				String revisionName = m1a.group(&quot;revision&quot;).toLowerCase();</span>
				// TODO: replace generateFullGraphOfRevision with query
				// rewriting option
<span class="fc" id="L187">				String tempGraphName = graphName + &quot;-temp&quot;;</span>
<span class="fc" id="L188">				RevisionManagement.generateFullGraphOfRevision(graphName, revisionName, tempGraphName);</span>
<span class="fc" id="L189">				String GraphClause = QueryParser.getStringEnclosedinBraces(whereClause, m1a.end());</span>
<span class="fc" id="L190">				queryRewritten += String.format(&quot;GRAPH &lt;%s&gt; { %s }&quot;, tempGraphName, GraphClause);</span>
<span class="fc" id="L191">			}</span>
<span class="fc" id="L192">			queryRewritten += &quot;}&quot;;</span>
		}

<span class="fc" id="L195">		logger.debug(&quot;Rewritten query for update: &quot; + queryRewritten);</span>

		// (IIIa) Remove empty insert clauses which otherwise will lead to
		// errors
<span class="fc" id="L199">		m = patternEmptyGraphPattern.matcher(queryRewritten);</span>
<span class="fc" id="L200">		queryRewritten = m.replaceAll(&quot;&quot;);</span>

		// IV. Execute rewritten query (updating changesets)
<span class="fc" id="L203">		TripleStoreInterfaceSingleton.get().executeUpdateQuery(queryRewritten);</span>

		// V. add changesets to full graph and add meta information in revision
		// graphs
<span class="fc bfc" id="L207" title="All 2 branches covered.">		for (RevisionDraft draft : revList) {</span>
<span class="fc" id="L208">			RevisionManagement.addNewRevisionFromChangeSet(commit.user, commit.message, draft);</span>
<span class="fc" id="L209">		}</span>
<span class="fc" id="L210">	}</span>

	public static String sparqlCreateGraph(final String query) throws QueryErrorException {
<span class="nc" id="L213">		final Pattern patternCreateGraph = Pattern.compile(&quot;CREATE\\s*(?&lt;silent&gt;SILENT)?\\s*GRAPH\\s*&lt;(?&lt;graph&gt;[^&gt;]*)&gt;&quot;,</span>
				patternModifier);
<span class="nc" id="L215">		String graphName = null;</span>
<span class="nc" id="L216">		Matcher m = patternCreateGraph.matcher(query);</span>
<span class="nc" id="L217">		boolean found = false;</span>
<span class="nc bnc" id="L218" title="All 2 branches missed.">		while (m.find()) {</span>
<span class="nc" id="L219">			found = true;</span>
<span class="nc" id="L220">			graphName = m.group(&quot;graph&quot;);</span>
			// String silent = m.group(&quot;silent&quot;);

			// Create graph
<span class="nc" id="L224">			TripleStoreInterfaceSingleton.get().executeCreateGraph(graphName);</span>

<span class="nc" id="L226">			RevisionGraph graph = new RevisionGraph(graphName);</span>
<span class="nc bnc" id="L227" title="All 2 branches missed.">			if (graph.getMasterRevisionNumber() == null) {</span>
				// Add R43ples information
<span class="nc" id="L229">				RevisionManagement.putGraphUnderVersionControl(graphName);</span>
			}
<span class="nc" id="L231">		}</span>
<span class="nc bnc" id="L232" title="All 2 branches missed.">		if (!found) {</span>
<span class="nc" id="L233">			throw new QueryErrorException(&quot;Query doesn't contain a correct CREATE query:\n&quot; + query);</span>
		}
<span class="nc" id="L235">		return graphName;</span>
	}

	public static void sparqlDropGraph(final String query) throws QueryErrorException {
<span class="nc" id="L239">		final Pattern patternDropGraph = Pattern.compile(&quot;DROP\\s*(?&lt;silent&gt;SILENT)?\\s*GRAPH\\s*&lt;(?&lt;graph&gt;[^&gt;]*)&gt;&quot;,</span>
				patternModifier);
<span class="nc" id="L241">		Matcher m = patternDropGraph.matcher(query);</span>
<span class="nc" id="L242">		boolean found = false;</span>
<span class="nc bnc" id="L243" title="All 2 branches missed.">		while (m.find()) {</span>
<span class="nc" id="L244">			found = true;</span>
<span class="nc" id="L245">			String graphName = m.group(&quot;graph&quot;);</span>
<span class="nc" id="L246">			RevisionGraph graph = new RevisionGraph(graphName);</span>
<span class="nc" id="L247">			graph.purgeRevisionInformation();</span>
<span class="nc" id="L248">		}</span>
<span class="nc bnc" id="L249" title="All 2 branches missed.">		if (!found) {</span>
<span class="nc" id="L250">			throw new QueryErrorException(&quot;Query contain errors:\n&quot; + query);</span>
		}
<span class="nc" id="L252">	}</span>

	public static void sparqlTagOrBranch(final R43plesCommit commit)
			throws InternalErrorException, QueryErrorException {
<span class="fc" id="L256">		final Pattern patternBranchOrTagQuery = Pattern.compile(</span>
				&quot;(?&lt;action&gt;TAG|BRANCH)\\s*GRAPH\\s*&lt;(?&lt;graph&gt;[^&gt;]*)&gt;\\s*REVISION\\s*\&quot;(?&lt;revision&gt;[^\&quot;]*)\&quot;\\s*TO\\s*\&quot;(?&lt;name&gt;[^\&quot;]*)\&quot;&quot;,
				patternModifier);
<span class="fc" id="L259">		Matcher m = patternBranchOrTagQuery.matcher(commit.query_sparql);</span>

<span class="fc" id="L261">		boolean foundEntry = false;</span>
<span class="fc bfc" id="L262" title="All 2 branches covered.">		while (m.find()) {</span>
<span class="fc" id="L263">			foundEntry = true;</span>
<span class="fc" id="L264">			String action = m.group(&quot;action&quot;);</span>
<span class="fc" id="L265">			String graphName = m.group(&quot;graph&quot;);</span>
<span class="fc" id="L266">			String revisionNumber = m.group(&quot;revision&quot;).toLowerCase();</span>
<span class="fc" id="L267">			String referenceName = m.group(&quot;name&quot;).toLowerCase();</span>
<span class="fc bfc" id="L268" title="All 2 branches covered.">			if (action.equals(&quot;TAG&quot;)) {</span>
<span class="fc" id="L269">				RevisionManagement.createTag(graphName, revisionNumber, referenceName, commit.user, commit.message);</span>
<span class="pc bpc" id="L270" title="1 of 2 branches missed.">			} else if (action.equals(&quot;BRANCH&quot;)) {</span>
<span class="fc" id="L271">				RevisionManagement.createBranch(graphName, revisionNumber, referenceName, commit.user, commit.message);</span>
			} else {
<span class="nc" id="L273">				throw new QueryErrorException(&quot;Error in query: &quot; + commit.query_sparql);</span>
			}
<span class="fc" id="L275">		}</span>
<span class="pc bpc" id="L276" title="1 of 2 branches missed.">		if (!foundEntry) {</span>
<span class="nc" id="L277">			throw new QueryErrorException(&quot;Error in query: &quot; + commit.query_sparql);</span>
		}
<span class="fc" id="L279">	}</span>

	public static MergeResult sparqlMerge(final R43plesMergeCommit commit) throws InternalErrorException {
<span class="fc bfc" id="L282" title="All 2 branches covered.">		if (commit.action.equals(&quot;MERGE&quot;))</span>
<span class="fc" id="L283">			return mergeThreeWay(commit);</span>
<span class="fc bfc" id="L284" title="All 2 branches covered.">		else if (commit.action.equals(&quot;REBASE&quot;))</span>
<span class="fc" id="L285">			return mergeRebase(commit);</span>
<span class="pc bpc" id="L286" title="1 of 2 branches missed.">		else if (commit.action.equals(&quot;MERGE FF&quot;))</span>
<span class="fc" id="L287">			return mergeFastForward(commit);</span>
		else
<span class="nc" id="L289">			throw new InternalErrorException(&quot;Merge Query has errors&quot;);</span>
	}

	/**
	 * 
	 * 
	 * @return if fast-forward was successful
	 * @throws InternalErrorException
	 */
	public static MergeResult mergeFastForward(final R43plesMergeCommit commit) throws InternalErrorException {
<span class="fc" id="L299">		RevisionGraph graph = new RevisionGraph(commit.graphName);</span>
<span class="fc" id="L300">		MergeResult result = new MergeResult(commit);</span>
<span class="pc bpc" id="L301" title="1 of 2 branches missed.">		result.hasConflict = !FastForwardControl.performFastForward(graph, commit.branchNameB, commit.branchNameA, commit.user,</span>
				RevisionManagement.getDateString(), commit.message);

<span class="fc" id="L304">		return result;</span>
	}

	/**
	 * 
	 * @param graphName
	 * @param branchNameA
	 * @param branchNameB
	 * @param with
	 * @param triples
	 * @param type
	 * @param sdd
	 * @param user
	 * @param commitMessage
	 * @param format
	 * @return
	 * @throws InternalErrorException
	 */
	public static MergeResult mergeThreeWay(final R43plesMergeCommit commit) throws InternalErrorException {

<span class="fc" id="L324">		RevisionGraph graph = new RevisionGraph(commit.graphName);</span>
<span class="fc" id="L325">		String revisionGraph = graph.getRevisionGraphUri();</span>
<span class="fc" id="L326">		String revisionUriA = graph.getRevisionUri(commit.branchNameA);</span>
<span class="fc" id="L327">		String revisionUriB = graph.getRevisionUri(commit.branchNameB);</span>

<span class="fc" id="L329">		MergeResult mresult = new MergeResult(commit);</span>

<span class="pc bpc" id="L331" title="1 of 2 branches missed.">		if (!RevisionManagement.checkGraphExistence(commit.graphName)) {</span>
<span class="nc" id="L332">			logger.warn(&quot;Graph &lt;&quot; + commit.graphName + &quot;&gt; does not exist.&quot;);</span>
<span class="nc" id="L333">			throw new InternalErrorException(&quot;Graph &lt;&quot; + commit.graphName + &quot;&gt; does not exist.&quot;);</span>
		}

		// Check if A and B are different revisions
<span class="pc bpc" id="L337" title="1 of 2 branches missed.">		if (graph.getRevisionNumber(commit.branchNameA)</span>
				.equals(graph.getRevisionNumber(commit.branchNameB))) {
			// Branches are equal - throw error
<span class="nc" id="L340">			throw new InternalErrorException(&quot;Specified branches are equal&quot;);</span>
		}

		// Check if both are terminal nodes
<span class="pc bpc" id="L344" title="2 of 4 branches missed.">		if (!(graph.hasBranch(commit.branchNameA)</span>
				&amp;&amp; graph.hasBranch(commit.branchNameB))) {
<span class="nc" id="L346">			throw new InternalErrorException(&quot;No terminal nodes were used&quot;);</span>
		}

		// Differ between MERGE query with specified SDD and without SDD
<span class="fc" id="L350">		String usedSDDURI = graph.getSDD(commit.sdd);</span>

		// Get the common revision with shortest path
<span class="fc" id="L353">		mresult.commonRevision = MergeManagement.getCommonRevisionWithShortestPath(revisionGraph, revisionUriA,</span>
				revisionUriB);

		// Create the revision progress for A and B
<span class="fc" id="L357">		String graphNameA = commit.graphName + &quot;-RM-REVISION-PROGRESS-A&quot;;</span>
<span class="fc" id="L358">		String graphNameB = commit.graphName + &quot;-RM-REVISION-PROGRESS-B&quot;;</span>
<span class="fc" id="L359">		String graphNameDiff = commit.graphName + &quot;-RM-DIFFERENCE-MODEL&quot;;</span>
<span class="fc" id="L360">		mresult.graphDiff = graphNameDiff;</span>
<span class="fc" id="L361">		String uriA = &quot;http://eatld.et.tu-dresden.de/branch-A&quot;;</span>
<span class="fc" id="L362">		String uriB = &quot;http://eatld.et.tu-dresden.de/branch-B&quot;;</span>

<span class="fc" id="L364">		MergeManagement.createRevisionProgresses(revisionGraph, commit.graphName,</span>
				MergeManagement.getPathBetweenStartAndTargetRevision(revisionGraph, mresult.commonRevision,revisionUriA),
				graphNameA, uriA, 
				MergeManagement.getPathBetweenStartAndTargetRevision(revisionGraph,	mresult.commonRevision, revisionUriB),
				graphNameB, uriB);

		// Create difference model
<span class="fc" id="L371">		MergeManagement.createDifferenceTripleModel(commit.graphName, graphNameDiff, graphNameA, uriA, graphNameB, uriB,</span>
				usedSDDURI);

		// Differ between the different merge queries
<span class="pc bpc" id="L375" title="1 of 6 branches missed.">		if ((commit.type != null) &amp;&amp; (commit.type.equalsIgnoreCase(&quot;AUTO&quot;)) &amp;&amp; !commit.with) {</span>
<span class="fc" id="L376">			logger.debug(&quot;AUTO MERGE query detected&quot;);</span>
			// Create the merged revision
<span class="fc" id="L378">			mresult.newRevisionNumber = MergeManagement.createMergedRevision(commit, graphNameDiff, graphNameA, uriA, graphNameB, uriB, usedSDDURI,</span>
					MergeQueryTypeEnum.AUTO);
<span class="pc bpc" id="L380" title="2 of 6 branches missed.">		} else if ((commit.type != null) &amp;&amp; (commit.type.equalsIgnoreCase(&quot;MANUAL&quot;)) &amp;&amp; commit.with) {</span>
<span class="fc" id="L381">			logger.debug(&quot;MANUAL MERGE query detected&quot;);</span>
			// Create the merged revision
<span class="fc" id="L383">			mresult.newRevisionNumber = MergeManagement.createMergedRevision(commit, graphNameDiff, graphNameA, uriA, graphNameB, uriB, usedSDDURI,</span>
					MergeQueryTypeEnum.MANUAL);
<span class="pc bpc" id="L385" title="1 of 4 branches missed.">		} else if ((commit.type == null) &amp;&amp; commit.with) {</span>
<span class="fc" id="L386">			logger.debug(&quot;MERGE WITH query detected&quot;);</span>
			// Create the merged revision
<span class="fc" id="L388">			mresult.newRevisionNumber = MergeManagement.createMergedRevision(commit, graphNameDiff, graphNameA, uriA, graphNameB, uriB, usedSDDURI,</span>
					MergeQueryTypeEnum.WITH);
<span class="pc bpc" id="L390" title="2 of 4 branches missed.">		} else if ((commit.type == null) &amp;&amp; !commit.with) {</span>
<span class="fc" id="L391">			logger.debug(&quot;MERGE query detected&quot;);</span>
			// Check if difference model contains conflicts
<span class="fc" id="L393">			String queryASK = String.format(&quot;ASK { %n&quot; + &quot;	GRAPH &lt;%s&gt; { %n&quot;</span>
					+ &quot; 	?ref &lt;http://eatld.et.tu-dresden.de/sddo#isConflicting&gt; \&quot;true\&quot;^^&lt;http://www.w3.org/2001/XMLSchema#boolean&gt; . %n&quot;
					+ &quot;	} %n&quot; + &quot;}&quot;, graphNameDiff);
<span class="pc bpc" id="L396" title="1 of 2 branches missed.">			if (TripleStoreInterfaceSingleton.get().executeAskQuery(queryASK)) {</span>
				// Difference model contains conflicts
				// Return the conflict model to the client
<span class="fc" id="L399">				mresult.hasConflict = true;</span>
<span class="fc" id="L400">				mresult.conflictModel = RevisionManagement.getContentOfGraph(graphNameDiff, commit.format);</span>

			} else {
				// Difference model contains no conflicts
				// Create the merged revision
<span class="nc" id="L405">				mresult.newRevisionNumber = MergeManagement.createMergedRevision(commit, graphNameDiff, graphNameA, uriA, graphNameB, uriB, usedSDDURI,</span>
						MergeQueryTypeEnum.COMMON);
			}
<span class="fc" id="L408">		} else {</span>
<span class="nc" id="L409">			throw new InternalErrorException(&quot;This is not a valid MERGE query&quot;);</span>
		}
<span class="fc" id="L411">		return mresult;</span>
	}

	/**
	 * 
	 * @param graphName
	 * @param branchNameA
	 * @param branchNameB
	 * @param with
	 * @param triples
	 * @param type
	 * @param sdd
	 * @param user
	 * @param commitMessage
	 * @param format
	 * @return
	 * @throws InternalErrorException
	 */
	public static MergeResult mergeRebase(final R43plesMergeCommit commit) throws InternalErrorException {

<span class="fc" id="L431">		RevisionGraph graph = new RevisionGraph(commit.graphName);</span>
<span class="fc" id="L432">		String revisionGraph = graph.getRevisionGraphUri();</span>
<span class="fc" id="L433">		String revisionUriA = graph.getRevisionUri(commit.branchNameA);</span>
<span class="fc" id="L434">		String revisionUriB = graph.getRevisionUri(commit.branchNameB);</span>

<span class="fc" id="L436">		MergeResult mresult = new MergeResult(commit);</span>

<span class="fc" id="L438">		RebaseControl rebaseControl =  new RebaseControl(commit);</span>
<span class="fc" id="L439">		rebaseControl.checkIfRebaseIsPossible();</span>

		// Differ between MERGE query with specified SDD and without SDD
<span class="fc" id="L442">		String usedSDDURI = graph.getSDD(commit.sdd);</span>

		// Get the common revision with shortest path
<span class="fc" id="L445">		String commonRevision = MergeManagement.getCommonRevisionWithShortestPath(revisionGraph, revisionUriA,</span>
				revisionUriB);

		// create the patch and patch group
<span class="fc" id="L449">		LinkedList&lt;String&gt; revisionList = MergeManagement.getPathBetweenStartAndTargetRevision(revisionGraph,</span>
				commonRevision, revisionUriA);

<span class="fc" id="L452">		rebaseControl.createPatchGroupOfBranch(revisionGraph, revisionUriB, revisionList);</span>

		// Create the revision progress for A and B
<span class="fc" id="L455">		String graphNameA = commit.graphName + &quot;-RM-REVISION-PROGRESS-A&quot;;</span>
<span class="fc" id="L456">		String graphNameB = commit.graphName + &quot;-RM-REVISION-PROGRESS-B&quot;;</span>
<span class="fc" id="L457">		String graphNameDiff = commit.graphName + &quot;-RM-DIFFERENCE-MODEL&quot;;</span>
<span class="fc" id="L458">		String uriA = &quot;http://eatld.et.tu-dresden.de/branch-A&quot;;</span>
<span class="fc" id="L459">		String uriB = &quot;http://eatld.et.tu-dresden.de/branch-B&quot;;</span>

<span class="fc" id="L461">		MergeManagement.createRevisionProgresses(revisionGraph, commit.graphName,</span>
				MergeManagement.getPathBetweenStartAndTargetRevision(revisionGraph, commonRevision, revisionUriA),
				graphNameA, uriA,
				MergeManagement.getPathBetweenStartAndTargetRevision(revisionGraph, commonRevision, revisionUriB),
				graphNameB, uriB);

		// Create difference model
<span class="fc" id="L468">		MergeManagement.createDifferenceTripleModel(commit.graphName, graphNameDiff, graphNameA, uriA, graphNameB, uriB,</span>
				usedSDDURI);
		
<span class="pc bpc" id="L471" title="2 of 6 branches missed.">		if ((commit.type != null) &amp;&amp; (commit.type.equalsIgnoreCase(&quot;AUTO&quot;)) &amp;&amp; !commit.with) {</span>
<span class="fc" id="L472">			logger.info(&quot;AUTO REBASE query detected&quot;);</span>
			// Create the merged revision
<span class="fc" id="L474">			ArrayList&lt;String&gt; addedAndRemovedTriples = MergeManagement.createRebaseMergedTripleList(commit, graphNameDiff, graphNameA, uriA, graphNameB, uriB,</span>
					usedSDDURI, MergeQueryTypeEnum.AUTO);
<span class="fc" id="L476">			String addedAsNTriples = addedAndRemovedTriples.get(0);</span>
<span class="fc" id="L477">			String removedAsNTriples = addedAndRemovedTriples.get(1);</span>

<span class="fc" id="L479">			String basisRevisionNumber = rebaseControl.forceRebaseProcess();</span>
<span class="fc" id="L480">			RevisionManagement.createNewRevision(commit.graphName, addedAsNTriples, removedAsNTriples, commit.user, commit.message,</span>
					basisRevisionNumber);
<span class="fc" id="L482">			mresult.graphStrategy = &quot;auto-rebase&quot;;</span>
<span class="pc bpc" id="L483" title="5 of 6 branches missed.">		} else if ((commit.type != null) &amp;&amp; (commit.type.equalsIgnoreCase(&quot;MANUAL&quot;)) &amp;&amp; !commit.with) {</span>
<span class="nc" id="L484">			logger.info(&quot;MANUAL REBASE query detected&quot;);</span>
			// Create the merged revision
<span class="nc" id="L486">			ArrayList&lt;String&gt; addedAndRemovedTriples = MergeManagement.createRebaseMergedTripleList(commit, graphNameDiff, graphNameA, uriA, graphNameB, uriB,</span>
					usedSDDURI, MergeQueryTypeEnum.MANUAL);
<span class="nc" id="L488">			String addedAsNTriples = addedAndRemovedTriples.get(0);</span>
<span class="nc" id="L489">			String removedAsNTriples = addedAndRemovedTriples.get(1);</span>

<span class="nc" id="L491">			String basisRevisionNumber = rebaseControl.forceRebaseProcess();</span>
<span class="nc" id="L492">			RevisionManagement.createNewRevision(commit.graphName, addedAsNTriples, removedAsNTriples, commit.user, commit.message,</span>
					basisRevisionNumber);
<span class="nc" id="L494">			mresult.graphStrategy = &quot;manual-rebase&quot;;</span>
<span class="pc bpc" id="L495" title="1 of 4 branches missed.">		} else if ((commit.type == null) &amp;&amp; commit.with) {</span>
<span class="fc" id="L496">			logger.info(&quot;REBASE WITH query detected&quot;);</span>
			// Create the merged revision -- newTriples
<span class="fc" id="L498">			ArrayList&lt;String&gt; addedAndRemovedTriples = MergeManagement.createRebaseMergedTripleList(commit, graphNameDiff, graphNameA, uriA, graphNameB, uriB,</span>
					usedSDDURI, MergeQueryTypeEnum.WITH);
<span class="fc" id="L500">			String addedAsNTriples = addedAndRemovedTriples.get(0);</span>
<span class="fc" id="L501">			String removedAsNTriples = addedAndRemovedTriples.get(1);</span>

<span class="fc" id="L503">			String basisRevisionNumber = rebaseControl.forceRebaseProcess();</span>
<span class="fc" id="L504">			RevisionManagement.createNewRevision(commit.graphName, addedAsNTriples, removedAsNTriples, commit.user, commit.message,</span>
					basisRevisionNumber);

<span class="fc" id="L507">			mresult.graphStrategy = &quot;with-rebase&quot;;</span>
<span class="pc bpc" id="L508" title="2 of 4 branches missed.">		} else if ((commit.type == null) &amp;&amp; !commit.with) {</span>
<span class="fc" id="L509">			logger.info(&quot;COMMON REBASE query detected&quot;);</span>
			// Check if difference model contains conflicts
<span class="fc" id="L511">			String queryASK = String.format(&quot;ASK { %n&quot; + &quot;	GRAPH &lt;%s&gt; { %n&quot;</span>
					+ &quot; 	?ref &lt;http://eatld.et.tu-dresden.de/sddo#isConflicting&gt; \&quot;true\&quot;^^&lt;http://www.w3.org/2001/XMLSchema#boolean&gt; . %n&quot;
					+ &quot;	} %n&quot; + &quot;}&quot;, graphNameDiff);
<span class="fc bfc" id="L514" title="All 2 branches covered.">			if (TripleStoreInterfaceSingleton.get().executeAskQuery(queryASK)) {</span>
<span class="fc" id="L515">				mresult.hasConflict = true;</span>
			} else {
<span class="fc" id="L517">				rebaseControl.forceRebaseProcess();</span>
			}
<span class="fc" id="L519">			mresult.conflictModel = RevisionManagement.getContentOfGraph(graphNameDiff, commit.format);</span>

<span class="fc" id="L521">		} else {</span>
<span class="nc" id="L522">			throw new InternalErrorException(&quot;This is not a valid MERGE query&quot;);</span>
		}

<span class="fc" id="L525">		return mresult;</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>